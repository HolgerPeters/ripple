#!/usr/bin/env ruby

trap("INT") {exit}
trap("TERM") {exit}

$:.unshift File.join(File.dirname(__FILE__), *%w[.. lib])

help = <<HELP
Ripple is a lilypond generator.

Basic Command Line Usage:
  ripple                                                    # . -> .
  ripple <path to work  >                                   # . -> <path>

  Configuration is read from '<source>/<work>/_work.yml' but can be overriden
  using the following options:

HELP

require 'optparse'
require 'ripple'

exec = {}
options = {}
opts = OptionParser.new do |opts|
  opts.banner = help

  opts.on("-p", "--parts PART", "Parts (comma-separated)") do |v|
    options["selected_parts"] = v
  end
  
  opts.on("-m", "--mvts MVT", "Movements (comma-separated)") do |v|
    options["selected_movements"] = v
  end
  
  opts.on("--midi", "Generate midi file") do |v|
    options["midi"] = true
    options["score_only"] = true # implied
  end
  
  opts.on("--no-midi", "Disable midi file generation") do |v|
    options["midi"] = false
  end
  
  opts.on("--opt OPT", "Option override (key:value,key:value)") do |v|
    v.split(",").each do |kv|
      if kv =~ /(.+):(.+)/ 
        options[$1] = $2
      else
        puts "Invalid option specified, please use key:value format"
        exit
      end
    end
  end
  
  opts.on("--no-pdf", "Generate Lilypond file only") do
    options["no_pdf"] = true
  end
  
  opts.on("-s", "--score", "Generate only score, no parts") do
    options["score_only"] = true
  end
  
  opts.on("-o", "--open", "Open PDF/Midi file after processing") do
    options["open_target"] = true
  end

  opts.on("-v", "--version", "Display current version") do
    puts "Ripple " + Ripple.version
    exit 0
  end
  
  opts.on("--auto", "Force auto mode") do
    options["auto"] = true
  end
  
  opts.on("--no-auto", "Disable auto mode") do
    options["auto"] = false
  end
end

opts.parse!

# Get source and destintation from command line
case ARGV.size
when 0
  $work = nil
when 1
  $work = ARGV[0]
else
  puts "Invalid options. Run `ripple --help` for assistance."
  exit(1)
end

$config = Ripple.configuration(options)
$works = Ripple.works($config)

def process
  if $work
    $work.split(',').each {|w| Ripple::Work.new(w, $config).process}
  elsif $works.empty?
    puts "No music found."
  else
    $works.each {|w| w.process}
  end
end

# Files to watch
def globs(source)
  Dir.chdir(source) do
    dirs = Dir['*'].select { |x| File.directory?(x) }
    
    # exclude _ly, _pdf, _midi dirs
    if (d = $config['ly_dir']) =~ /^\.\/(.*)/
      dirs -= [$1]
    end
    if (d = $config['pdf_dir']) =~ /^\.\/(.*)/
      dirs -= [$1]
    end
    if (d = $config['midi_dir']) =~ /^\.\/(.*)/
      dirs -= [$1]
    end
    
    dirs = dirs.map { |x| "#{x}/**/*" }
    dirs += ['*']
  end
end

if options["auto"]
  require 'directory_watcher'
  puts "Auto-regenerating enabled: #{$config['source']} -> #{$config['pdf_dir']}"

  dw = DirectoryWatcher.new($config['source'])
  dw.interval = 1
  dw.glob = globs($config['source'])

  dw.add_observer do |*args|
    t = Time.now.strftime("%Y-%m-%d %H:%M:%S")
    puts "[#{t}] regeneration: #{args.size} files changed"
    process
  end

  dw.start

  loop { sleep 1000 }
else
  # just process once
  process
end
